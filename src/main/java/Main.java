import controller.Controller;
import model.Model;
import view.View;

public  class Main  {
    public static void main(String[] args) {
        Model model = new Model();
        View view = new View();
        Controller controller = new Controller(model,view);
        controller.processUser();

        String s1 = "abc";
        char[] c = new char[]{'a','b','c'};
        String s2 = new String(c).intern();
        System.out.println(s1 == s2);

       /* бесплатно
        распространяемый комплект разработчика приложений
        на языке Java, включающий в себя компилятор Java
        (javac), стандартные библиотеки классов Java,
                примеры, документацию, различные утилиты и
        исполнительную систему Java (JRE).*/

       /* Управление памятью в стеке осуществляется по схеме
        LIFO.

                Стековая память существует лишь какое-то время работы
        программы, а память в куче живет с самого начала до
        конца работы программы.

                Мы можем использовать -Xms и -Xmx опции JVM, чтобы
        определить начальный и максимальный размер памяти в
        куче. Для стека определить размер памяти можно с
        помощью опции -Xss .

                Если память стека полностью занята, то Java Runtime
        бросает java.lang.StackOverflowError, а если память кучи
        заполнена, то бросается исключение
        java.lang.OutOfMemoryError: Java Heap Space.

                Размер памяти стека намного меньше памяти в куче. Из-
                за простоты распределения памяти (LIFO), стековая
        память работает намного быстрее кучи.*/

    /*    Когда мы используем оператор new, виртуальная
        машина создает объект String, но не хранит его в пуле
        строк. Мы можем использовать метод intern() для
        сохранения строки в пуле строк, или получения ссылки,
        если такая строка уже находится в пуле.*/
    }
}

